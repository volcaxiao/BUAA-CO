# 状态编码的分享

## 写在前头

相信的大家都开始写状态机了，FSM分为三个部分，主要是状态转移、状态储存、状态输出，其中状态转移、状态输出主要是组合逻辑的操作，因此将这两个模块封装后，可以进行类似于组合逻辑的电路的黑箱测试的操作。
当然，我们可以用分析电路(analyze circuit)的功能，非常方便的得到我们想要的电路。
这些问题都解决了，留给我们自己的事情就只剩下状态编码的选择、状态转移（输出）的真值表了。
> 当然，还有计算机组成课程历史上的一颗明珠——qshr机（指路[自主研发：权尚浩然型有限状态机](http://cscore.buaa.edu.cn/#/discussion_area/579/689/posts)），可以省去选状态编码这种憋死选择困难症的操作，直观可读性强，是计算机仿真史上的一个重大发明，虚拟现实专业的同学也应该好好学习借鉴

---

所以我们来重点看看选择状态编码的门道。
这里我们以logisim导航这一题为例，看看不同的状态编码的选择之间的差别。

## 目录

[状态转移图](#状态转移图)
[自己乱编的码](#自己乱编的码)
[8421顺序编码](#8421顺序编码)
[格雷码](#格雷码)
[独热码](#独热码)
[瞻仰qshr机](#瞻仰qshr机)

## 状态转移图

- 这道题的状态转移图，其实不太好用常见的圈箭头的表示，倒是路径图已经有了，直接在这上面看着打表会方便一点
![自己乱编码的图](%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81%E5%88%86%E4%BA%AB/1%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BC%96%E7%A0%81%E5%9B%BE.jpg)

## 自己乱编的码

> 编码中还需要注意一个问题，就是我们输入的三位数从高位到地位应该是(l2,l1,l0),所以在我们打表的时候的命名请按照(l2,l1,l0,d1,d0)的顺序(分别表示location,direction),同样输出我们使用(L2,L1,L0,hit)的顺序。这样符合逻辑！

> 在打完表以后，也要注意，分离器(splitter)分离出来的位次依次是(l0,l1,l2)，所以为了好看，打完表以后，把输入输出的顺序调一下！调成(l0,l1,l2,hit)

- 上图是我自己的胡乱编码，其实也不胡乱，中间三个状态是独热码表示。他的效果如下：
![自己码](%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81%E5%88%86%E4%BA%AB/1%E8%87%AA%E5%B7%B1%E7%A0%81.png)

## 8421顺序编码

- 顺序编码是我们最好理解的一种编码，最符合我们人类的直觉往往最不符合计算机的直觉，因为虽然顺序编码的最为紧密（紧密也有紧密的好处），但是由于相邻两个状态之间的变化太大，实际的硬件的寄存器很难做到同时发生变化，所以出错的概率很高（我们叫做毛刺现象）。
- 所以在我们平常的作业中使使可能没太大问题，但是实际应用中用的很少。
![8421码](%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81%E5%88%86%E4%BA%AB/2_8421%E7%A0%81.png)

## 格雷码

- 格雷码的特点就是解决了顺序码的缺点，相邻的两状态之间编码之变一位，就不会出现毛刺的现象。
- 但是格雷码最大的问题在于设计的难度
- 其实格雷码最好是初态和末态也只差一位，但我实在有点找不到，有能够找到的dl可以在评论区指出。
![格雷码](%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81%E5%88%86%E4%BA%AB/3_%E6%A0%BC%E9%9B%B7%E7%A0%81.png)

## 独热码

- 独热码的编码可能是唯一一个计算机好理解，人也好理解的编码，再加上他一下只需要变动两次（置一+置零），所以毛刺的概率低。
- 而且，虽然说编码不太紧密，用到的寄存器位数多（也就是触发器多），但是这也使得组合逻辑电路会精简一些，大家可以看接下来的实现。
- 就是这两个特点使得独热码在实际应用中十分广泛。
  > 独热码适合写条件复杂但是状态少的状态机；
    格雷码适合写条件不复杂但是状态多的状态机。
- 这里分享一个小妙招，格雷码一个一个的在Analysis里打表不方便（位数太多了），而其实独热码大多数位数都是零，所以可以先构造出这样的电路
![独热码构造捷径](%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81%E5%88%86%E4%BA%AB/%E7%8B%AC%E7%83%AD%E7%A0%81%E6%9E%84%E9%80%A0%E6%8D%B7%E5%BE%84.png)
- 然后再Project -> Analyze circuit,出来的初始真值表就是全置零的啦。
- 如下图（独热码的真值表太长了我就不晒出来了）
![独热码](%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81%E5%88%86%E4%BA%AB/4_%E7%8B%AC%E7%83%AD%E7%A0%81.png)
- 当然这肯定不是最简化的电路，你可以根据要求自己搭更加简单的电路，包括说用复用器来实现更简化，在这里就不赘述了。

## 瞻仰qshr机

- 对于qshr机，评论区zytgg的评论一针见血：
  > 是否等价于把独热编码的状态机按位拆开？
  - 确实，独热码的思路就是有多少状态就用多少触发器，qshr机也就是这么个道理，每一个状态都用一个寄存器存下，和我们画状态转移图的时候的思路是一致的。

> 介于qshr机在计算机仿真史上做出的贡献，我们看到了，对于这个题navigation来说，有很直观的状态转移图，还记得我在最开始说的嘛，"这道题的状态转移图，其实不太好用常见的圈箭头的表示，倒是路径图已经有了，直接在这上面看着打表会方便一点"，不用打表，题图即是状态转移图！！！

- 所以我们把原基础的qshr机封装一下，让他看起来更具有仿真的意味！
![qshr机封装版](%E7%8A%B6%E6%80%81%E7%BC%96%E7%A0%81%E5%88%86%E4%BA%AB/qshr%E6%9C%BA%E6%94%B9%E8%89%AF%E7%89%88.png)

- 虽然只是对qshr机的拙略模仿，但是你们不觉得很酷嘛，这很符合我对未来的想象（）。

---

## 写到最后

- 其实有限状态机核心的部分就是状态转移，状态转移核心的部分就是编码选择和打表，掌握好了这几个地方，封装再好点（便于调试），有限状态机就不难啦。
- 感谢qshr大佬的灵感支持！
- 感谢zyt、cys等佬的理论拓展！
- 有不妥之处请各位大佬指出，谢谢观看！
